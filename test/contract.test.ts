import path from 'path'

import { expect, assert } from 'chai'
import { Framework } from '@vechain/connex-framework'
import { Driver, SimpleNet, SimpleWallet } from '@vechain/connex-driver'
import { keccak256 } from 'thor-devkit'

import { compileContract, getABI } from '../src/utils'
import { Contract } from '../src/contract'
import { errs } from '../src/errs'
import { getReceipt, decodeEvent } from '../src/connexUtils'
import { soloAccounts } from '../src/builtin'
import { Connex } from '@vechain/connex'

describe('Contract', () => {
	const wallet = new SimpleWallet()
	// Add the first private key generated by the thor solo mode
	soloAccounts.forEach(acc => { wallet.import(acc) })

	let conn: Framework
	let driver: Driver
	before(async () => {
		try {
			driver = await Driver.connect(new SimpleNet('http://localhost:8669/'), wallet)
			conn = new Framework(driver)
		} catch (err) {
			assert.fail('Failed to connect: ' + err)
		}
	})

	after(() => {
		try {
			driver.close()
		} catch (err) {
			assert.fail('Failed to disconnect: ' + err)
		}
	})

	const filePath = path.resolve(process.cwd(), './test/contracts/B.sol')
	const abiB = JSON.parse(compileContract(filePath, 'B', 'abi'))
	const binB = compileContract(filePath, 'B', 'bytecode')
	const B = new Contract({ abi: abiB, bytecode: binB })
	const C = new Contract({
		abi: JSON.parse(compileContract(filePath, 'C', 'abi')),
		bytecode: compileContract(filePath, 'C', 'bytecode')
	})

	describe('Error checking', () => {
		it('constructor', () => {
			let wrapper: () => void
			wrapper = () => { new Contract({ abi: [] }) }
			expect(wrapper).to.throw(TypeError, errs.abi.Empty().message)

			wrapper = () => { new Contract({ abi: abiB, address: '0x12' }) }
			expect(wrapper).to.throw(TypeError, errs.InvalidAddress('0x12').message)

			wrapper = () => { new Contract({ abi: abiB, bytecode: '0x12s' }) }
			expect(wrapper).to.throw(TypeError, errs.InvalidHex('0x12s').message)
		})

		it('at', () => {
			const c = new Contract({ abi: abiB })
			const addr = '0x1234567890'
			const wrapper = () => { c.at(addr) }
			expect(wrapper).to.throw(TypeError, errs.InvalidAddress(addr).message)
		})

		it('bytecode', () => {
			const c = new Contract({ abi: abiB })
			const bin = '0x082342s'
			const wrapper = () => { c.bytecode(bin) }
			expect(wrapper).to.throw(TypeError, errs.InvalidHex(bin).message)
		})

		it('call', () => {
			const c = new Contract({ abi: abiB })

			let wrapper: () => void
			wrapper = () => { c.call('test') }
			expect(wrapper).to.throw(TypeError, errs.contract.ConnexNotSet().message)

			c.connex(conn)
			expect(wrapper).to.throw(TypeError, errs.contract.AddressNotSet().message)

			c.at('0x' + '0'.repeat(40))
			expect(wrapper).to.throw(TypeError, errs.abi.NotFound('test', 'function', 0).message)

			wrapper = () => { c.call('set') }
			expect(wrapper).to.throw(TypeError, errs.abi.InvalidStateMutability('nonpayable').message)
		})

		it('send', () => {
			const c = new Contract({ abi: abiB })

			let wrapper: () => void
			wrapper = () => { c.send('test', 0) }
			expect(wrapper).to.throw(TypeError, errs.abi.NotFound('test', 'function', 0).message)

			wrapper = () => { c.send('get', 0) }
			expect(wrapper).to.throw(TypeError, errs.abi.InvalidStateMutability('view').message)

			wrapper = () => { c.send('set', 0) }
			expect(wrapper).to.throw(TypeError, errs.contract.AddressNotSet().message)

			// Incorrect number of parameters
			c.at(wallet.list[0].address)
			wrapper = () => { c.send('set', 0, 10, 10, 10) }
			expect(wrapper).to.throw(TypeError, errs.abi.NotFound('set', 'function', 3).message)
		})

		it('deploy', () => {
			const c = new Contract({ abi: abiB })

			let wrapper: () => void
			wrapper = () => { c.deploy(0) }
			expect(wrapper).to.throw(TypeError, errs.contract.BytecodeNotSet().message)

			// missing parameter
			c.bytecode(binB)
			wrapper = () => { c.deploy(0) }
			expect(wrapper).to.throw()
		})

		it('abi', () => {
			const c = new Contract({ abi: abiB })

			let wrapper: () => void
			wrapper = () => { c.ABI("test", "function") }
			expect(wrapper).to.throw(TypeError, errs.contract.ABINotFound().message)

			let actual = c.ABI('set', 'function')
			let keys = Object.keys(actual)
			let vals = Object.values(actual)

			expect(vals[keys.indexOf('name')]).to.eql('set')
			expect(vals[keys.indexOf('type')]).to.eql('function')
			expect(vals[keys.indexOf('inputs')].length).to.eql(1)

			actual = c.ABI('set', 'function', 2)
			keys = Object.keys(actual)
			vals = Object.values(actual)

			expect(vals[keys.indexOf('name')]).to.eql('set')
			expect(vals[keys.indexOf('type')]).to.eql('function')
			expect(vals[keys.indexOf('inputs')].length).to.eql(2)
		})
	})

	let receipt: Connex.Thor.Transaction.Receipt
	let txResp: Connex.Vendor.TxResponse
	let callOutput: Connex.VM.Output & Connex.Thor.Account.WithDecoded

	it('deploy contract with a constructor', async () => {
		const initVal = 101

		txResp = await conn.vendor.sign('tx', [B.deploy(0, initVal)]).request()
		receipt = await getReceipt(conn, 5, txResp.txid)
		expect(receipt.reverted).to.equal(false)
		expect(receipt.outputs[0].contractAddress).not.equal(null)

		if (receipt.outputs[0].contractAddress !== null) {
			B.at(receipt.outputs[0].contractAddress)
		}

		B.connex(conn)
		callOutput = await B.call('get')
		expect(parseInt(callOutput.data, 16)).to.equal(initVal)
	})

	it('deploy contract without a constructor', async () => {
		txResp = await conn.vendor.sign('tx', [C.deploy(0)]).request()
		receipt = await getReceipt(conn, 5, txResp.txid)
		expect(receipt.reverted).to.equal(false)

		if (receipt.outputs[0].contractAddress !== null) {
			C.at(receipt.outputs[0].contractAddress)
		}
		C.connex(conn)
	})

	it('transfer VET to the deployed contract', async () => {
		const value = 1e8 * 1e18
		const clause = { to: C.address, value: '0x' + BigInt(value).toString(16) }

		// console.log(C.address)

		txResp = await conn.vendor.sign('tx', [clause]).signer(wallet.list[1].address).request()
		receipt = await getReceipt(conn, 5, txResp.txid)
		expect(receipt.reverted).to.eql(false)

		let balance = await C.getBalance()
		expect(parseInt(balance.balance.slice(2), 16) / 1e18).to.eql(value / 1e18)
		expect(parseInt(balance.energy.slice(2), 16) / 1e18).to.eql(0)

		const ticker = conn.thor.ticker()
		for (; ;) {
			await ticker.next()
			const status = conn.thor.status
			const t = new Date()

			if (10 * 1000 - (t.getTime() - status.head.timestamp * 1000) < 1000) {
				continue
			}

			const dur = status.head.timestamp - receipt.meta.blockTimestamp

			// console.log(`dur = ${dur}`)

			balance = await conn.thor.account(C.address).get()
			expect(parseInt(balance.energy.slice(2), 16) / 1e18).to.eql(value / 1e18 * dur * 5 / 1e9)

			break
		}
	})

	it('contract call with tx', async () => {
		const newVal = 201

		txResp = await conn.vendor.sign('tx', [B.send('set', 0, newVal)]).request()
		receipt = await getReceipt(conn, 5, txResp.txid)

		expect(receipt.reverted).to.equal(false)
		expect(receipt.outputs[0].events.length).to.equal(2)

		const topics = [
			'0x' + keccak256('SetA(uint256)').toString('hex'),
			'0x' + keccak256('SetB(uint256)').toString('hex')]
		receipt.outputs[0].events.forEach((event, i) => {
			expect(event.topics[0]).to.eql(topics[i])
			expect(parseInt(event.topics[1], 16)).to.equal(newVal)
		})

		const decoded = decodeEvent(receipt.outputs[0].events[1], getABI(abiB, 'SetB', 'event'))
		expect(parseInt(decoded['a'])).to.eql(newVal)

		callOutput = await B.call('get')
		expect(parseInt(callOutput.data, 16)).to.equal(newVal)
		callOutput = await B.call('get', 123)
		expect(parseInt(callOutput.data, 16)).to.equal(newVal + 123)
	})
})