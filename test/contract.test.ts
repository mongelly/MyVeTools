import path from 'path'
import { expect, assert } from 'chai'
import { Framework } from '@vechain/connex-framework'
import { Driver, SimpleNet, SimpleWallet } from '@vechain/connex-driver'
import { keccak256 } from 'thor-devkit'

import { compileContract, getABI } from '../src/utils'
import { Contract } from '../src/contract'
import { errs } from '../src/errs'
import { getReceipt, decodeEvent } from '../src/connexUtils'
import { soloAccounts } from '../src/builtin'

const filePath = path.resolve(process.cwd(), './test/contracts/B.sol')
const abiB = JSON.parse(compileContract(filePath, 'B', 'abi'))
const bytecode = compileContract(filePath, 'B', 'bytecode')
const B = new Contract({ abi: abiB }).bytecode(bytecode)

describe('Contract', () => {
	const wallet = new SimpleWallet()

	// Add the first private key generated by the thor solo mode
	wallet.import(soloAccounts[0])

	let conn: Framework
	let driver: Driver
	before(async () => {
		try {
			driver = await Driver.connect(new SimpleNet('http://localhost:8669/'), wallet)
			conn = new Framework(driver)
			B.connex(conn)
		} catch (err) {
			assert.fail('Failed to connect: ' + err)
		}
	})

	after(() => {
		try {
			driver.close()
		} catch (err) {
			assert.fail('Failed to disconnect: ' + err)
		}
	})

	describe('Error checking', () => {
		it('constructor', () => {
			let wrapper: () => void
			wrapper = () => { new Contract({ abi: [] }) }
			expect(wrapper).to.throw(TypeError, errs.abi.Empty().message)

			wrapper = () => { new Contract({ abi: abiB, address: '0x12' }) }
			expect(wrapper).to.throw(TypeError, errs.InvalidAddress('0x12').message)

			wrapper = () => { new Contract({ abi: abiB, bytecode: '0x12s' }) }
			expect(wrapper).to.throw(TypeError, errs.InvalidHex('0x12s').message)
		})

		it('at', () => {
			const c = new Contract({ abi: abiB })
			const addr = '0x1234567890'
			const wrapper = () => { c.at(addr) }
			expect(wrapper).to.throw(TypeError, errs.InvalidAddress(addr).message)
		})

		it('bytecode', () => {
			const c = new Contract({ abi: abiB })
			const bin = '0x082342s'
			const wrapper = () => { c.bytecode(bin) }
			expect(wrapper).to.throw(TypeError, errs.InvalidHex(bin).message)
		})

		it('call', () => {
			const c = new Contract({ abi: abiB })

			let wrapper: () => void
			wrapper = () => { c.call('test') }
			expect(wrapper).to.throw(TypeError, errs.contract.ConnexNotSet().message)

			c.connex(conn)
			expect(wrapper).to.throw(TypeError, errs.contract.AddressNotSet().message)

			c.at('0x' + '0'.repeat(40))
			expect(wrapper).to.throw(TypeError, errs.abi.NotFound('test', 'function').message)

			wrapper = () => { c.call('set') }
			expect(wrapper).to.throw(TypeError, errs.abi.InvalidStateMutability('nonpayable').message)
		})

		it('send', () => {
			const c = new Contract({ abi: abiB })

			let wrapper: () => void
			wrapper = () => { c.send('test', 0) }
			expect(wrapper).to.throw(TypeError, errs.abi.NotFound('test', 'function').message)

			wrapper = () => { c.send('get', 0) }
			expect(wrapper).to.throw(TypeError, errs.abi.InvalidStateMutability('view').message)

			wrapper = () => { c.send('set', 0) }
			expect(wrapper).to.throw(TypeError, errs.contract.AddressNotSet().message)

			// missing parameter
			c.at(wallet.list[0].address)
			wrapper = () => { c.send('set', 0) }
			expect(wrapper).to.throw()
		})

		it('deploy', () => {
			const c = new Contract({ abi: abiB })

			let wrapper: () => void
			wrapper = () => { c.deploy(0) }
			expect(wrapper).to.throw(TypeError, errs.contract.BytecodeNotSet().message)

			// missing parameter
			c.bytecode(bytecode)
			wrapper = () => { c.deploy(0) }
			expect(wrapper).to.throw()
		})
	})

	let receipt: Connex.Thor.Transaction.Receipt
	let output: Connex.Vendor.TxResponse
	let callOutput: Connex.VM.Output & Connex.Thor.Account.WithDecoded
	let dryRunOut: Connex.VM.Output[]

	it('deploy contract', async () => {
		const initVal = 101

		try {
			const clause = B.deploy(0, initVal)
			
			dryRunOut = await conn.thor.explain([clause]).execute()
			expect(dryRunOut[0].reverted).to.equal(false)

			output = await conn.vendor.sign('tx', [clause]).request()
		} catch (err) {
			assert.fail('deployContract: ' + err)
		}

		try {
			receipt = await getReceipt(
				conn, 		// connex instance
				5, 				// timeout: number of blocks
				output.txid		// txid
			)
		} catch (err) { assert.fail('getReceipt: ' + err) }

		expect(receipt.reverted).to.equal(false)
		expect(receipt.outputs[0].contractAddress).not.equal(null)

		if (receipt.outputs[0].contractAddress !== null) {
			B.at(receipt.outputs[0].contractAddress)
		}

		try {
			callOutput = await B.call('get')
		} catch (err) {
			assert.fail('contractCall: ' + err)
		}
		expect(parseInt(callOutput.data, 16)).to.equal(initVal)

		// Test when constructor is missing
		try {
			const C = new Contract({
				abi: JSON.parse(compileContract(filePath, 'C', 'abi')),
				bytecode: compileContract(filePath, 'C', 'bytecode')
			})
			const clause = C.deploy(0)
			dryRunOut = await conn.thor.explain([clause]).execute()
			expect(dryRunOut[0].reverted).to.equal(false)
		} catch (err) { assert.fail('Failed to generate default constructor: ' + err) }
	})

	it('contract call with tx', async () => {
		const newVal = 201

		try {
			const clause = B.send('set', 0, newVal)

			dryRunOut = await conn.thor.explain([clause]).execute()
			expect(dryRunOut[0].reverted).to.equal(false)

			output = await conn.vendor.sign('tx', [clause]).request()
		} catch (err) { assert.fail('contractCallWithTx: ' + err) }

		try {
			receipt = await getReceipt(
				conn, 		// connex instance
				5, 				// timeout: number of blocks
				output.txid		// txid
			)
		} catch (err) { assert.fail('getReceipt: ' + err) }

		expect(receipt.reverted).to.equal(false)
		expect(receipt.outputs[0].events.length).to.equal(2)

		const topics = [
			'0x' + keccak256('SetA(uint256)').toString('hex'),
			'0x' + keccak256('SetB(uint256)').toString('hex')]
		receipt.outputs[0].events.forEach((event, i) => {
			expect(event.topics[0]).to.eql(topics[i])
			expect(parseInt(event.data, 16)).to.equal(newVal)
		})

		try {
			const decoded = decodeEvent(receipt.outputs[0].events[1], getABI(abiB, 'SetB', 'event'))
			expect(parseInt(decoded['_a'])).to.eql(newVal)
		} catch (err) { assert.fail('decodeEvent: ' + err) }

		try {
			callOutput = await B.call('get')
		} catch (err) { assert.fail('contractCall: ' + err) }
		expect(parseInt(callOutput.data, 16)).to.equal(newVal)
	})
})